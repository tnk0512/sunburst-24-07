<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Tree Partition with CIELab Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
    .arc text {
        font: 10px sans-serif;
        text-anchor: middle;
    }
    .arc path {
        stroke: #fff;
    }
    .tooltip {
        position: absolute;
        visibility: hidden;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 12px;
    }
    .dimmed {
        opacity: 0.4;
    }
</style>
</head>
<body>
    <div class="tooltip" style="opacity: 0;"></div>
    <div id="nodeCount">Nodes displayed: 0</div>
    <div id="overview" style="position: absolute; top: 10px; right: 10px; width: 250px; height: 250px; border: 1px solid #ccc;"></div>
    <script>
        var width = 900,
            height = 760,
            maxradius = Math.min(width, height) / 2;

        var x = d3.scale.linear().range([0, 2 * Math.PI]);
        var y = d3.scale.linear().range([0, maxradius]);

        var partition = d3.layout.partition().value(function(d) { return d.value || 1; }).sort(null);

        var arc = d3.svg.arc()
            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
            .innerRadius(function(d) { return Math.max(0, y(d.y)); })
            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");

        var tooltip = d3.select("body").append("div").attr("class", "tooltip");

        // 基準
        var sizeCriterion = 12; // クリック可能なノード
        var labelCriterion = 50; // ラベルを表示するノード

        function drawChart(root, clicked) {
            var nodes = partition.nodes(root);
            var maxdepth = d3.max(nodes, function(d) { return d.depth; });
            var levels = 5;

            if (clicked) {
                y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]);
            } else {
                y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([0, maxradius]);
            }

            var initialNodes = nodes.filter(function(d) { return d.depth < levels; });

            var path = svg.selectAll("path").data(initialNodes).enter().append("path")
                .attr("d", arc)
                .style("fill", fillColor)
                .on("click", click)
                .on("mouseover", mouseover)
                .on("mouseout", mouseout);

            var text = svg.selectAll("text")
                .data(initialNodes.filter(function(d) {
                    var r = y(d.y + d.dy / 2); // Average radius of the arc
                    var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                    return r * theta >= labelCriterion;
                }))
                .enter().append("text")
                .attr("transform", function(d) {
                    return "translate(" + arc.centroid(d) + ")";
                })
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .text(function(d) {
                    return d.name;
                });

            updateNodeCount(initialNodes);
        }

        $.ajax({
            url: "/data",
            type: "POST",
            contentType: "application/json",
            success: function(root) {
                drawChart(root, false);
                var previousTopNode = null;
            },
            error: function(xhr, status, error) {
                console.error("Error:", error);
            }
        });
        /*
        d3.json("/data", function(error, root) {
            if (error) throw error;
            drawChart(root, false);
            var previousTopNode = null;
        });*/

        function click(d) {
            var startAngle = x(d.x);
            var endAngle = x(d.x + d.dx);
            let initialColor = d3.select(this).style("fill");
            console.log("start", startAngle, "end", endAngle);
        
            $.ajax({
                url: "/subtree",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({ target_name: d.name }),
                success: function(response) {
                    if (response.error) {
                        alert("Error: " + response.error);
                        return;
                    }
        
                    var subtree = response.subtree;
                    var parentNode = response.parent;
        
                    svg.selectAll("path").remove();
                    svg.selectAll("text").remove(); // ラベルをクリア
        
                    var nodes = partition.nodes(subtree);
                    var maxdepth = d3.max(nodes, function(d) { return d.depth; });
                    var levels = 5;
        
                    y.domain([0, maxdepth < levels ? 1 : levels / maxdepth]).range([20, maxradius]);
                    x.range([startAngle, endAngle]);
        
                    var path = svg.selectAll("path").data(nodes).enter().append("path")
                        .attr("d", arc)
                        .style("fill", fillColor)
                        .on("click", click)
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout);
        
                    // 親ノードをクリックした場合の特別なトランジション
                    if (d.depth === 0 && previousTopNode) {
                        let previousNode = nodes.find(n => n.name === previousTopNode.name);
                        if (previousNode) {
                            let n_x = previousNode.x;
                            let n_dx = previousNode.dx;
                        svg.transition()
                            .duration(1000)
                            .tween("scale", function() {
                                let targetDepth = Math.min(d.y + 5 * d.dy, 1);
                                let //xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
                                    xd = d3.interpolate([n_x, n_x + n_dx], [0, 1]),
                                    yd = d3.interpolate(y.domain(), [d.y, 1]),
                                    yr = d3.interpolate(y.range(), [d.y ? 20 : 0, maxradius]);
                                return function(t) {
                                    //let adjustedT = t < 0.4 ? 2.5 * t : 1;
                                    x.domain(xd(t));
                                    y.domain(yd(t)).range(yr(t));
                                };
                            })
                            .selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
                            .styleTween("fill", function(d) {
                                //let initialColor = d3.select(this).style("fill");
                                let targetColor = fillColor(d);
                                return function(t) {
                                    return d3.interpolateLab(initialColor, targetColor)(t);
                                };
                            })
                            .each("end", function(e, i) {
                                if (i === 0) {
                                    updateNodeCount(nodes);
                                    // Show the new labels after the transition ends
                                    svg.selectAll("text").remove(); // Clear any remaining labels
                                    var text = svg.selectAll("text")
                                        .data(nodes.filter(function(d) {
                                            var r = y(d.y + d.dy / 2); // Average radius of the arc
                                            var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                                            return r * theta >= labelCriterion;
                                        }))
                                        .enter().append("text")
                                        .attr("transform", function(d) {
                                            return "translate(" + arc.centroid(d) + ")";
                                        })
                                        .attr("text-anchor", "middle")
                                        .attr("font-size", "10px")
                                        .text(function(d) {
                                            return d.name;
                                        })
                                        .style("visibility", function(d) {
                                            return isNodeVisible(d, x.domain(), y.domain()) ? "visible" : "hidden";
                                        });
                                }
                            });
                        previousTopNode = d;
                        }
                    } else {
                    previousTopNode = d;
                    svg.transition().duration(1000).tween("scale", function() {
                        var xr = d3.interpolate(x.range(), [0, 2 * Math.PI]);
                        return function(t) {
                            x.range(xr(t));
                        };
                    }).selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
                    .styleTween("fill", function(d) {
                            let initialColor = d3.select(this).style("fill");
                            return function(t) {
                                return d3.interpolateLab(initialColor, fillColor(d))(t);
                            };
                        })
                    .each("end", function(e, i) {
                        if (i === 0) {
                            updateNodeCount(nodes);
                            // Show the new labels after the transition ends
                            svg.selectAll("text").remove(); // Clear any remaining labels
                            var text = svg.selectAll("text")
                                .data(nodes.filter(function(d) {
                                    var r = y(d.y + d.dy / 2); // Average radius of the arc
                                    var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                                    return r * theta >= labelCriterion;
                                }))
                                .enter().append("text")
                                .attr("transform", function(d) {
                                    return "translate(" + arc.centroid(d) + ")";
                                })
                                .attr("text-anchor", "middle")
                                .attr("font-size", "10px")
                                .text(function(d) {
                                    return d.name;
                                })
                                .style("visibility", function(d) {
                                    return isNodeVisible(d, x.domain(), y.domain()) ? "visible" : "hidden";
                                });
                        }
                    });
                }
                    if (parentNode) {
                        parentNode.depth = 0;
                        parentNode.x = 0;
                        parentNode.dx = 1;
                        parentNode.y = 0;
                        parentNode.dy = 1;
                        var parentY = d3.scale.linear().range([0, 20]);
        
                        var parentPath = svg.append("path")
                            .datum(parentNode)
                            .attr("d", function(d) {
                                var arcParent = d3.svg.arc()
                                    .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                    .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                    .innerRadius(function(d) { return Math.max(0, parentY(d.y)); })
                                    .outerRadius(function(d) { return Math.max(0, parentY(d.y + d.dy)); });
                                return arcParent(d);
                            })
                            .style("fill", "#fff")
                            .style("opacity", 1)  // 親ノードは不透明
                            .on("click", click)
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);}
        
                    updateNodeCount(nodes);
            },
                error: function(xhr, status, error) {
                    console.error("Error:", error);
                }
            });
        }


        function fillColor(d) {
            let distance = y(d.y);
            let angle = x(d.x);
            let [L, a, b] = polarToCIELab(distance, angle, maxradius);
            return LabToHex(L, a, b);
        }

        function updateNodeCount(nodes) {
            var visibleNodes = nodes.filter(function(d) {
                return isNodeVisible(d, x.domain(), y.domain());
            });
            d3.select("#nodeCount").text("Number of visible nodes: " + visibleNodes.length);
        }

        function mouseover(d) {
            let nodeColor = d3.select(this).style("fill");
            let labColor = d3.lab(nodeColor);

            var r = y(d.y + d.dy / 2);
            var theta = x(d.x + d.dx) - x(d.x);
            var rTheta = r * theta;

            tooltip.style("visibility", "visible")
                .html(`Node: ${d.name}<br>r: ${r.toFixed(2)}, θ: ${theta.toFixed(2)}<br>r * θ: ${rTheta.toFixed(2)}<br>Color (CIELab): ${labColor.toString()}`);
        }

        function mouseout(d) {
            tooltip.style("visibility", "hidden");
        }

        svg.on("mousemove", function() {
            tooltip.style("top", (d3.event.pageY + 10) + "px")
                   .style("left", (d3.event.pageX + 10) + "px");
        });

        function polarToCIELab(distance, angle, maxDistance) {
            let L = 100 * (1 - 3 * distance / (4 * maxDistance));
            let a = 160 * distance / maxDistance * Math.cos(angle);
            let b = 160 * distance / maxDistance * Math.sin(angle);
            return [L, a, b];
        }

        function LabToHex(L, a, b) {
            let labColor = d3.lab(L, a, b);
            let rgbColor = labColor.rgb();
            return rgbColor.toString();
        }

        function isNodeVisible(d, xDomain, yDomain) {
            return d.x >= xDomain[0] && (d.x + d.dx) <= xDomain[1] && d.y >= yDomain[0] && (d.y + d.dy) <= yDomain[1];
        }
    </script>
</body>
</html>