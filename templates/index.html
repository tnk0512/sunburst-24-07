<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Tree Partition with CIELab Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<style>
    .arc text {
        font: 10px sans-serif;
        text-anchor: middle;
    }
    .arc path {
        stroke: #fff;
    }
    .tooltip {
        position: absolute;
        visibility: hidden;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 12px;
    }
    .dimmed {
        opacity: 0.4;
    }
</style>
</head>
<body>
    <div class="tooltip" style="opacity: 0;"></div>
    <div id="nodeCount">Nodes displayed: 0</div>
    <div id="overviewContainer" style="position: relative; width: 250px; height: 250px; border: 1px solid #ccc;">
    </div>
    <script>
        var width = 900,
            height = 760,
            maxradius = Math.min(width, height) / 2;

        var overwidth = 250,
            overheight = 250,
            overmaxradius = Math.min(overwidth, overheight) / 2;

        var maxdepth = 11;  // biota->20, simple->5, viruses->11
        var levels = 5;

        var x = d3.scale.linear().range([0, 2 * Math.PI]);
        var y = d3.scale.linear().range([0, maxradius]);

        var partition = d3.layout.partition().value(function(d) { return d.value || 1; }).sort(null);

        var arc = d3.svg.arc()
            .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
            .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
            .innerRadius(function(d) { return Math.max(0, y(d.y)); })
            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });


        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");


        var tooltip = d3.select("body").append("div").attr("class", "tooltip");
        var overviewSvg;

        // 基準
        var sizeCriterion = 12; // クリック可能なノード
        var labelCriterion = 50; // ラベルを表示するノード

        function drawChart(root) {
            var nodes = partition.nodes(root);
          
            // Draw the overview image in the container
            $.ajax({
                url: '/get_image',
                type: 'GET',
                success: function(data) {
                    var img = $('<img />', {
                        src: '/static/images/overview_viruses.png',
                        width: '250px',
                        height: '250px'
                    });
                    $('#overviewContainer').empty().append(img);
                    // Create the SVG element on top of the image
                    overviewSvg = d3.select("#overviewContainer").append("svg")
                            .attr("width", 250)
                            .attr("height", 250)
                            .style("position", "absolute")
                            .style("top", "0px")
                            .style("left", "0px")
                            .append("g")
                            .attr("transform", "translate(" + (250 / 2) + "," + (250 / 2) + ")");
                
                            var overviewX = d3.scale.linear().range([0, 2 * Math.PI]);
                            var overviewY = d3.scale.linear().range([0, overmaxradius * 5 / (maxdepth+1)]);
                
                            var overviewArc = d3.svg.arc()
                                .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, overviewX(d.x))); })
                                .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, overviewX(d.x + d.dx))); })
                                .innerRadius(function(d) { return Math.max(0, overviewY(d.y)); })
                                .outerRadius(function(d) { return Math.max(0, overviewY(d.y + d.dy)); });
                
                            overviewSvg.selectAll("path")
                                .data(nodes)
                                .enter().append("path")
                                .attr("d", overviewArc)
                                .style("fill", function(d) {
                                    d.overviewColor = fillColor(d); // Save the original color
                                    return d.overviewColor;
                                })
                                .on("click", click);
                    
                            },
                error: function(xhr, status, error) {
                    console.error("Error loading image:", error);
                }
            });


            var path = svg.selectAll("path").data(nodes).enter().append("path")
                .attr("d", arc)
                .style("fill", fillColor);
            
            // Non-clickable paths
            var ClickablePaths = path.filter(function(d) {
                var r = y(d.y + d.dy / 2); // Average radius of the arc
                var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                return r * theta > sizeCriterion;
            });
        
            // Clickable paths
            var clickablePaths = path.filter(function(d) {
                return ClickablePaths.data().includes(d);
            });
        
            clickablePaths.on("click", click)
                .on("mouseover", mouseover)
                .on("mouseout", mouseout);

            var text = svg.selectAll("text")
                .data(nodes.filter(function(d) {
                    var r = y(d.y + d.dy / 2); // Average radius of the arc
                    var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                    return r * theta >= labelCriterion;
                }))
                .enter().append("text")
                .attr("transform", function(d) {
                    return "translate(" + arc.centroid(d) + ")";
                })
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .text(function(d) {
                    return d.name;
                });

            updateNodeCount(nodes);
        }

        $.ajax({
            url: "/data",
            type: "POST",
            contentType: "application/json",
            success: function(root) {
                var previousTopNode = null;
                drawChart(root);
            },
            error: function(xhr, status, error) {
                console.error("Error:", error);
            }
        });
        var previousClickDepth = 0;
        var previousStartAngle = 0; // 追加：前回の開始角度
        var previousEndAngle = 2 * Math.PI; // 追加：前回の終了角度

        function click(d) {
            var startAngle = x(d.x);
            var endAngle = x(d.x + d.dx);
            let initialColor = d3.select(this).style("fill");
            var clickedNodeParent = d.parent;
            
            // クリックノードの真のルートノードからの深さを再帰的に求める
            function getNodeDepth(node, previousDepth) {
                if(d.depth === 0 && previousTopNode){
                    return previousDepth - 1;
                }
                if (!node.parent) {
                    return previousDepth - 1;
                }
                return getNodeDepth(node.parent, previousDepth + 1);
            }
            
            var nodeDepth = getNodeDepth(d, previousClickDepth);
            
            // 現在の深さを保存して次回のクリック時に使用
            previousClickDepth = nodeDepth;
        
            $.ajax({
                url: "/subtree",
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({ target_name: d.name }),
                success: function(response) {
                    if (response.error) {
                        alert("Error: " + response.error);
                        return;
                    }
        
                    var subtree = response.subtree;
                    var parentNode = response.parent;
        
                    svg.selectAll("path").remove();
                    svg.selectAll("text").remove(); // ラベルをクリア
        
                    var nodes = partition.nodes(subtree);
        
                    y.domain([0, d3.max(nodes, function(d) { return d.depth; }) < levels ? 1 : levels / d3.max(nodes, function(d) { return d.depth; })]).range([20, maxradius]);
                    x.range([startAngle, endAngle]);

                    var path = svg.selectAll("path").data(nodes).enter().append("path")
                        .attr("d", arc)
                        .style("fill", fillColor);

                    // Ensure the parent node is clickable
                    var clickablePaths = path.filter(function(d) {
                        var r = y(d.y + d.dy / 2); 
                        var theta = x(d.x + d.dx) - x(d.x); 
                        return r * theta >= sizeCriterion ||  d === clickedNodeParent; // クリックノードの親ノードはrが負の値のため
                    });
                
                    clickablePaths.on("click", click)
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout);

                    if (d.depth === 0 && previousTopNode) {
                        let previousNode = nodes.find(n => n.name === previousTopNode.name);
                            if (previousNode) {
                                let n_x = previousNode.x;
                                let n_dx = previousNode.dx;
                                
                                // Overview の設定
                                var overstartAngle = (previousStartAngle*(n_x+n_dx) - previousEndAngle*n_x)/n_dx;
                                var overendAngle = (previousStartAngle*(n_x+n_dx-1)-previousEndAngle*(n_x-1))/n_dx;
                    }} else {
                        var overstartAngle = previousStartAngle + (previousEndAngle - previousStartAngle) * d.x;
                        var overendAngle = previousStartAngle + (previousEndAngle - previousStartAngle) * (d.x + d.dx);
                    }
                    previousStartAngle = overstartAngle; // 追加：前回の開始角度を保存
                    previousEndAngle = overendAngle; // 追加：前回の終了角度を保存
                    overviewX = d3.scale.linear().range([overstartAngle, overendAngle]);
                    overviewY = d3.scale.linear().range([
                        overmaxradius * nodeDepth / maxdepth,
                        overmaxradius * (nodeDepth + 4 < maxdepth ? nodeDepth + 4 : maxdepth) / maxdepth
                    ]);
        
                    var overviewArc = d3.svg.arc()
                        .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, overviewX(d.x))); })
                        .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, overviewX(d.x + d.dx))); })
                        .innerRadius(function(d) { return Math.max(0, overviewY(d.y)); })
                        .outerRadius(function(d) { return Math.max(0, overviewY(d.y + d.dy)); });
        
                    var overviewSvg = d3.select("#overviewContainer").select("svg").select("g");
        
                    overviewSvg.selectAll("path").remove();
        
                    overviewSvg.selectAll("path")
                        .data(nodes)
                        .enter().append("path")
                        .attr("d", overviewArc)
                        .style("fill", function(d) {
                            d.overviewColor = fillColor(d); // Save the original color
                            return d.overviewColor;
                        })
                        .on("click", click);
        
                    // 親ノードをクリックした場合の特別なトランジション
                    if (d.depth === 0 && previousTopNode) {
                        let previousNode = nodes.find(n => n.name === previousTopNode.name);
                        if (previousNode) {
                            let n_x = previousNode.x;
                            let n_dx = previousNode.dx;
                            
                            svg.transition()
                                .duration(1000)
                                .tween("scale", function() {
                                    let targetDepth = Math.min(d.y + 5 * d.dy, 1);
                                    let //xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
                                        xd = d3.interpolate([n_x, n_x + n_dx], [0, 1]),
                                        yd = d3.interpolate(y.domain(), [d.y, 1]),
                                        yr = d3.interpolate(y.range(), [d.y ? 20 : 0, maxradius]);
                                    return function(t) {
                                        //let adjustedT = t < 0.4 ? 2.5 * t : 1;
                                        x.domain(xd(t));
                                        y.domain(yd(t)).range(yr(t));
                                    };
                                })
                                .selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
                                .styleTween("fill", function(d) {
                                    //let initialColor = d3.select(this).style("fill");
                                    let targetColor = fillColor(d);
                                    return function(t) {
                                        return d3.interpolateLab(initialColor, targetColor)(t);
                                    };
                                })
                                .each("end", function(e, i) {
                                    if (i === 0) {
                                        updateNodeCount(nodes);
                                        // Show the new labels after the transition ends
                                        svg.selectAll("text").remove(); // Clear any remaining labels
                                        var text = svg.selectAll("text")
                                            .data(nodes.filter(function(d) {
                                                var r = y(d.y + d.dy / 2); // Average radius of the arc
                                                var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                                                return r * theta >= labelCriterion;
                                            }))
                                            .enter().append("text")
                                            .attr("transform", function(d) {
                                                return "translate(" + arc.centroid(d) + ")";
                                            })
                                            .attr("text-anchor", "middle")
                                            .attr("font-size", "10px")
                                            .text(function(d) {
                                                return d.name;
                                            })
                                            .style("visibility", function(d) {
                                                return isNodeVisible(d, x.domain(), y.domain()) ? "visible" : "hidden";
                                            });
                                    }
                                });
                            previousTopNode = d;
                        }
                    } else {
                    previousTopNode = d;

                    svg.transition().duration(1000).tween("scale", function() {
                        var xr = d3.interpolate(x.range(), [0, 2 * Math.PI]);
                        return function(t) {
                            x.range(xr(t));
                        };
                    }).selectAll("path").attrTween("d", function(d) { return function() { return arc(d); }; })
                    .styleTween("fill", function(d) {
                            let initialColor = d3.select(this).style("fill");
                            return function(t) {
                                return d3.interpolateLab(initialColor, fillColor(d))(t);
                            };
                        })
                    .each("end", function(e, i) {
                        if (i === 0) {
                            updateNodeCount(nodes);
                            // Show the new labels after the transition ends
                            svg.selectAll("text").remove(); // Clear any remaining labels
                            var text = svg.selectAll("text")
                                .data(nodes.filter(function(d) {
                                    var r = y(d.y + d.dy / 2); // Average radius of the arc
                                    var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
                                    return r * theta >= labelCriterion;
                                }))
                                .enter().append("text")
                                .attr("transform", function(d) {
                                    return "translate(" + arc.centroid(d) + ")";
                                })
                                .attr("text-anchor", "middle")
                                .attr("font-size", "10px")
                                .text(function(d) {
                                    return d.name;
                                })
                                .style("visibility", function(d) {
                                    return isNodeVisible(d, x.domain(), y.domain()) ? "visible" : "hidden";
                                });
                        }
                    });
                }
                    if (parentNode) {
                        parentNode.depth = 0;
                        parentNode.x = 0;
                        parentNode.dx = 1;
                        parentNode.y = 0;
                        parentNode.dy = 1;
                        var parentY = d3.scale.linear().range([0, 20]);
        
                        var parentPath = svg.append("path")
                            .datum(parentNode)
                            .attr("d", function(d) {
                                var arcParent = d3.svg.arc()
                                    .startAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
                                    .endAngle(function(d) { return Math.PI/2 - Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
                                    .innerRadius(function(d) { return Math.max(0, parentY(d.y)); })
                                    .outerRadius(function(d) { return Math.max(0, parentY(d.y + d.dy)); });
                                return arcParent(d);
                            })
                            .style("fill", "#fff")
                            .style("opacity", 1)  // 親ノードは不透明
                            .on("click", click)
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);}
        
                    updateNodeCount(nodes);
            },
                error: function(xhr, status, error) {
                    console.error("Error:", error);
                }
            });
        }


        function fillColor(d) {
            let distance = y(d.y);
            let angle = x(d.x);
            let [L, a, b] = polarToCIELab(distance, angle, maxradius);
            return LabToHex(L, a, b);
        }

        function updateNodeCount(nodes) {
            var visibleNodes = nodes.filter(function(d) {
                return isNodeVisible(d, x.domain(), y.domain());
            });
            d3.select("#nodeCount").text("Number of visible nodes: " + visibleNodes.length);
        }

        function mouseover(d) {
            let nodeColor = d3.select(this).style("fill");
            let labColor = d3.lab(nodeColor);

            var r = y(d.y + d.dy / 2);
            var theta = x(d.x + d.dx) - x(d.x);
            var rTheta = r * theta;

            tooltip.style("visibility", "visible")
                .html(`Node: ${d.name}<br>r: ${r.toFixed(2)}, θ: ${theta.toFixed(2)}<br>r * θ: ${rTheta.toFixed(2)}<br>Color (CIELab): ${labColor.toString()}`);
            if (rTheta >= sizeCriterion) {
                overviewSvg.selectAll("path")
                    .filter(function(node) { return node === d; })
                    .style("fill", "white");
                }
        }

        function mouseout(d) {
            tooltip.style("visibility", "hidden");
            // Restore the color of the corresponding node on the overview
            var r = y(d.y + d.dy / 2); // Average radius of the arc
            var theta = x(d.x + d.dx) - x(d.x); // Angle in radians
            if (r * theta >= sizeCriterion) {
                overviewSvg.selectAll("path")
                    .filter(function(od) { return od === d; })
                    .style("fill", function(d) { return d.overviewColor; });
                }
        }

        svg.on("mousemove", function() {
            tooltip.style("top", (d3.event.pageY + 10) + "px")
                   .style("left", (d3.event.pageX + 10) + "px");
        });

        function polarToCIELab(distance, angle, maxDistance) {
            let L = 100 * (1 - 3 * distance / (4 * maxDistance));
            let a = 160 * distance / maxDistance * Math.cos(angle);
            let b = 160 * distance / maxDistance * Math.sin(angle);
            return [L, a, b];
        }

        function LabToHex(L, a, b) {
            let labColor = d3.lab(L, a, b);
            let rgbColor = labColor.rgb();
            return rgbColor.toString();
        }

        function isNodeVisible(d, xDomain, yDomain) {
            return d.x >= xDomain[0] && (d.x + d.dx) <= xDomain[1] && d.y >= yDomain[0] && (d.y + d.dy) <= yDomain[1];
        }
    </script>
</body>
</html>